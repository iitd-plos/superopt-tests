# Differential Fuzzing with `afl-fuzz`

## Setup
The benchmarking script takes a csv as input, which has information about the benchmarks that need to be tested. It outputs a csv which has details about the pairs which were found to be inequivalent. The format of the output csv is as follows:

| `Function Name` | `src benchmark` | `dst benchmark` | `Unroll Factor` | `Tool Result` | `Time taken (s)` |
| ----------------| --------------- | ----------------| --------------- | ------------- | ---------------- |
|     memccpy     |   dietlibc.c    |    freebsd.c    |        1        |     INEQ      | 34.50189766008407|

Since this file only contains bugs, `Tool Result` will always be `INEQ`. The fuzzing script takes this file as input, and generates fuzzing harnesses for each `(func, src, dst)` triplet. We might have multiple harness designs for each `func` (discussed later).

## Harness Design

We are given two different implementations of the same function. We want to use a fuzzer to figure out if there is an input that differentiates the two implementations.

### Idea

- Write a fuzzing harness which passes the same input to both the implementations, and aborts if their outputs (return values and memory regions) differ
- The fuzzer will try to find an input which triggers a crash (which will be a bug in our case)
- For each `(f, src, dst)` triplet, implement the following methods:
  - `fuzz_harness_{f}(int argc, char** argv, ...)`: it is assumed that `argv[1]` contains the name of the input file. This method should appropriately parse the inputs
  - `main(int argc, char** argv)`: this method should call `fuzz_harness_{f}()` to parse the inputs and appropriately call both the `src` and `dst` implementations and see if the bug is triggered
  - We may have multiple harness designs for a given `f` (more specifically, multiple implementations of `fuzz_harness_{f}()`). In such a case, we use macros to choose the implementation
  - For instance, we could have the following two designs for `memcpy(dst, src, n)`:
    - Non-overlapping memories: both `dst` and `src` memories would be non-overlapping, with an allocated size of `MAX_SIZE`
    - Overlapping memories: both `dst` and `src` lie at some offset in a "virtual memory" of size `VMEM_SIZE`, allowing for memory overlap to occur in the input. This harness can be enabled by compiling the harness with the flag `-DOVERLAP`
    - If there are `n` such macros, then there would be `2^n` total harness designs

## Directory Structure and Files

### `in/`
This directory contains one folder for each function `{func}`, which contains an input text file `{func}_input.txt`. These input files are parsed appropriately by the harnesses.

### `utils/fuzz_harness.c`
For each function `f`, contains the definition of `fuzz_harness_{f}()` (in case of multiple definitions, they are appropriately implemented with macros) 

### `src/`
Contains the source implementations which are to be checked by the fuzzer. Each filename has the format `{func}-{lib}.c`

### `include/`
Contains header files like `fuzz_harness.h`, `bench_prototype.h`, etc

### `harness/`
Contains the top level harness files which contains the `main()` functions, which in-turn invokes the implementations. Each filename has the format `fuzz-{func}-{src}-{dst}.c`

### `consts.py`
Contains function prototypes and harness templates for each function. These are used to automatically generate fuzzing harnesses for all the pairs in the input csv

### `fuzzing.py`
This file can be used to generate fuzzing harnesses and run fuzzing experiments. It can be invoked with a command line interface as follows:

#### Generating fuzzers
This commands takes the fuzzing pairs from `inp.csv` and generates all source files and harnesses in `src/` and `harness/` respectively. This also generates fuzzing binaries in `bin/`.
```shell
python3 fuzzing.py --input_file inp.csv --cc afl-fuzz
```

#### Running experiments
This command uses the generated binaries to run fuzzing experiments.

```shell
python3 fuzzing.py --input_file inp.csv --run_experiments --timeout t --njobs n --exec_time e
```

#### Analysis
This command analyzes the crashes and logs generated by the fuzzers and generates a json containing statistics about the bugs found by the fuzzer. See `inequivalences.csv.json` for an example output file

```shell
python3 fuzzing.py --input_file inp.csv --analysis
```

### `Makefile`
The makefile has the following targets:
- `make compile`: compiles the fuzzing binaries
- `make run`: runs the fuzzing experiments and runs the analysis
- `make clean`, `make clean_all`

### `install.sh`
Installs `afl-fuzz` on the system

### `system_config.sh`
The fuzzer requires some specific core_pattern and cpu scaling_governor setting. Calling `./system_config.sh apply` will apply the required changes and `./system_config.sh revert` will revert the changes
